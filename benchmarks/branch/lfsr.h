/*
 * Copyright (c) 2025 Technical University of Munich
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met: redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer;
 * redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution;
 * neither the name of the copyright holders nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
/**
 * @file
 *
 * This file implements pseudo-random number generators based on linear feedback shift registers (LFSR).
 *
 * Random numbers generated by the LFSR implemented in this file will produce a sequence that has a period
 * covering the full range of bits for the chosen LFSR. A well-designed n-bit LFSR will return numbers in
 * the range 1 to 2^n in a pseudo-random order with no repeating numbers until the full range has been exhausted.
 *
 * The following linear feedback shift registers are provided:
 * - Lfsr8:  8-bit LFSR with a period of 255
 * - Lfsr16: 16-bit LFSR with a period of 65,535
 * - Lfsr32: 32-bit LFSR with a period of 4,294,967,296
 * - Lfsr64: 64-bit LFSR with a period of 18,446,744,073,709,551,616
 */

#pragma once
#include <cstdint>

// LFSR8 represents an 8-bit linear feedback shift register
struct Lfsr8 {
    uint8_t state;
    uint8_t seed;

    Lfsr8(uint8_t _seed = 0) {
        this->seed = _seed;
        this->state = _seed;
    }

    uint8_t next() {
        uint8_t s = this->state;
        uint8_t b = (s >> 0) ^ (s >> 2) ^ (s >> 3) ^ (s >> 4);
        this->state = (s >> 1) | (b << 7);
        return this->state;
    }

    void reset() {
        this->state = this->seed;
    }
};

// LFSR16 represents a 16-bit linear feedback shift register
struct Lfsr16 {
    uint16_t state;
    uint16_t seed;

    Lfsr16(uint16_t _seed = 0) {
        this->seed = _seed;
        this->state = _seed;
    }

    uint16_t next() {
        uint16_t s = this->state;
        uint16_t b = (s >> 0) ^ (s >> 2) ^ (s >> 3) ^ (s >> 5);
        this->state = (s >> 1) | (b << 15);
        return this->state;
    }

    void reset() {
        this->state = this->seed;
    }
};

// LFSR32 represents a 32-bit linear feedback shift register
struct Lfsr32 {
    uint32_t state;
    uint32_t seed;

    Lfsr32(uint32_t _seed = 0) {
        this->seed = _seed;
        this->state = _seed;
    }

    uint32_t next() {
        uint32_t s = this->state;
        uint32_t b = (s >> 0) ^ (s >> 2) ^ (s >> 6) ^ (s >> 7);
        this->state = (s >> 1) | (b << 31);
        return this->state;
    }

    void reset() {
        this->state = this->seed;
    }
};

// LFSR64 represents a 64-bit linear feedback shift register
struct Lfsr64 {
    uint64_t state;
    uint64_t seed;

    Lfsr64(uint64_t _seed = 0) {
        this->seed = _seed;
        this->state = _seed;
    }

    uint64_t next() {
        uint64_t s = this->state;
        uint64_t b = (s >> 0) ^ (s >> 1) ^ (s >> 3) ^ (s >> 4);
        this->state = (s >> 1) | (b << 63);
        return this->state;
    }

    void reset() {
        this->state = this->seed;
    }
};
